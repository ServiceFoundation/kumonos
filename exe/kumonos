#!/usr/bin/env ruby
# frozen_string_literal: true

$:.unshift(File.expand_path('../lib', __dir__))
require 'json'
require 'yaml'

filename = ARGV[0]

config = YAML.load_file(filename)

def service_to_vhost(service)
  name = service['name']

  {
    name: name,
    domains: [name],
    routes: service['routes'].flat_map {|r| split_route(r, name) }
  }
end

# Split route config to apply retry config only to GET/HEAD requests.
def split_route(route, name)
  base = {
    prefix: route['prefix'],
    timeout_ms: route['timeout_ms'],
    cluster: name,
  }
  with_retry = base.merge(
    retry_policy: route['retry_policy'],
    headers: [{ name: ':method', value: '(GET|HEAD)', regex: true }],
  )
  [with_retry, base]
end

virtual_hosts = config['services'].map {|s| service_to_vhost(s) }

def service_to_cluster(service)
  out = {
    name: service['name'],
    connect_timeout_ms: service['connect_timeout_ms'],
    type: 'logical_dns',
    lb_type: 'round_robin',
    hosts: [ { url: "tcp://#{service['lb']}" }],
  }
  out.merge(circuit_breakers: [default: service['circuit_breaker']]) if service['circuit_breaker']
  out
end

clusters = config['services'].map {|s| service_to_cluster(s) }

out = {
  listeners: [
    {
      address: 'tcp://0.0.0.0:9211',
      filters: [
        type: 'read',
        name: 'http_connection_manager',
        config: {
          codec_type: 'auto',
          stat_prefix: 'ingress_http',
          access_log: [{ path: '/dev/stdout' }],
          route_config: {
            virtual_hosts: virtual_hosts,
          },
          filters: [{ type: 'decoder', name: 'router', config: {} }],
        }
      ],
    }
  ],
  admin: {
    access_log_path: "/dev/stdout",
    address: "tcp://0.0.0.0:9901"
  },
  cluster_manager: {
    clusters: clusters,
  }
}

puts JSON.dump(out)
