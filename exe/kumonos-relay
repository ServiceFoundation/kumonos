#!/usr/bin/env ruby
require 'optparse'
require 'socket'
require 'logger'

# Convert metric name
class StatConvertor
  def initialize(options)
    @options = options
  end

  def call(line)
    convert_status_code(convert_listener(convert_cluster(add_default_tag(line)))) + "\n"
  end

  private

  STATS_CODE_PATTERN = /(upstream|downstream)_rq_(\dxx|\d{3})/
  def convert_status_code(line)
    if line.match(STATS_CODE_PATTERN)
      stream = Regexp.last_match(1)
      code = Regexp.last_match(2)
      [
        line.gsub(STATS_CODE_PATTERN, "#{stream}_rq_by_code"),
        ",status_code:#{code}"
      ].join

    else
      line
    end
  end

  # envoy.cluster.ab-testing.external.upstream_rq_200:1|c
  CLUSTER_PATTERN = /\Aenvoy\.cluster\.([^.]+)\./
  def convert_cluster(line)
    if line.match(CLUSTER_PATTERN)
      name = Regexp.last_match(1)
      [
        line.gsub(CLUSTER_PATTERN, 'envoy.cluster.'),
        ",cluster:#{name}"
      ].join
    else
      line
    end
  end

  # XXX: ipv4 only
  # envoy.listener.0.0.0.0_9211.http.egress_http.downstream_rq_5xx:0|c
  LISTENER_PATTERN = /\Aenvoy\.listener\.(\d+\.\d+\.\d+.\d+_\d+)./
  def convert_listener(line)
    if line.match(LISTENER_PATTERN)
      listener = Regexp.last_match(1)
      [
        line.gsub(LISTENER_PATTERN, 'envoy.listener.'),
        ",listener:#{listener}"
      ].join
    else
      line
    end
  end

  def add_default_tag(line)
    [
      "#{line.chomp}|#",
      "service_cluster:#{@options[:service_cluster]},",
      "service_node:#{@options[:service_node]},",
      "host:#{@options[:host]}"
    ].join
  end
end

logger = Logger.new($stderr)
logger.level = ENV['LOG_LEVEL'] || 'info'

options = {
  service_cluster: '',
  service_node: '',
  host: Socket.gethostname
}
parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{__FILE__} [options] bind_address:port remote_address:port"

  opts.on('--service-cluster=VAL (required)') { |v| options[:service_cluster] = v }
  opts.on('--service-node=VAL (required)') { |v| options[:service_node] = v }
  opts.on('--host=VAL') { |v| options[:host] = v }
end

argv = parser.parse(ARGV)

if argv.size != 2
  warn parser.help
  exit 1
end
if options[:service_cluster].empty? || options[:service_node].empty?
  warn '--service-cluster and --service-node are required'
  warn parser.help
  exit 1
end

convertor = StatConvertor.new(options)

bind_option = argv.shift
remote_option = argv.shift

source_ip, source_port = *bind_option.split(':')
unless source_ip && source_port
  warn "Invalid bind option given: #{bind_option}"
  exit 1
end

remote_ip, remote_port = *remote_option.split(':')
unless remote_ip && remote_port
  warn "Invalid remote option given: #{remote_option}"
  exit 1
end

Thread.abort_on_exception = true
logger.info("Starting relay: source=#{bind_option} remote=#{remote_option}")
source = TCPServer.open(source_ip, source_port)

loop do
  Thread.start(source.accept) do |s|
    while (body = s.gets)
      logger.debug("recieved #{body.bytesize} bytes")
      logger.debug(body)
      next if body.empty?

      b = convertor.call(body)
      UDPSocket.new.send(b, Socket::MSG_DONTWAIT, remote_ip, remote_port)
      logger.debug("write #{b.bytesize} bytes")
      logger.debug(b)
    end
    s.close
  end
end
